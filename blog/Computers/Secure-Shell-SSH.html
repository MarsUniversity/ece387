<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <!-- <link rel='stylesheet' type='text/css' href='https://cdn.rawgit.com/MarsUniversity/ece387/master/website/pandoc.css'> -->
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
    	<link href="https://cdnjs.cloudflare.com/ajax/libs/cc-icons/1.2.1/css/cc-icons.min.css" rel="stylesheet">
    	<link href="https://cdn.rawgit.com/walchko/font-linux/v0.7.2/assets/font-linux.css" rel="stylesheet">
      <!-- <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"> -->
      <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro" rel="stylesheet">
      <link href="https://walchko.github.io/site.css" rel="stylesheet" type="text/css" />
      <!-- <link href="../../site.css" rel="stylesheet" type="text/css" /> -->
    	<!-- <link href="https://walchko.github.io/pygments.css" rel="stylesheet" type="text/css" /> -->
      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [["$","$"],["\\(","\\)"]]
          }
        });
      </script>

	  <!-- code pulled from jupyter nbconvert for syntax coloring -->
	  <style type="text/css">
    .highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>

    </head>
    <body>
      <div id="outer-wrapper">
        <div id="header-wrapper">
  <div class="title xtralarge bold"><a href="https://walchko.github.io/index.html">Planet Express</a></div>
  <div class="normal small"> Our crew is replaceable. Your package isn't. </div>

  <div class="nav normal">
    <a class="logo" href="https://walchko.github.io/index.html">Home</a>
    <a class="logo" href="https://walchko.github.io/colophon.html">Colophon</a>
    <a class="logo" href="https://walchko.github.io/about.html">About</a>
    <a class="logo" href="https://walchko.github.io/topics.html">Topics</a>
  </div>
</div>


          <div id="main">
            
            
              <h1 id="ssh">SSH</h1>
<dl>
<dt>date</dt>
<dd><p>2012-09-10</p>
</dd>
<dt>summary</dt>
<dd><p>SSH usage</p>
</dd>
</dl>
<figure>
<img src="pics/ssh.jpg" class="align-center" width="200" />
</figure>
<p>Secure Shell (<a href="http://www.openssh.org">SSH</a>) is a cryptographic network protocol for secure data communication, remote shell services or command execution and other secure network services between two networked computers that connects, via a secure channel over an insecure network, a server and a client (running SSH server and SSH client programs, respectively). The protocol specification distinguishes between two major versions that are referred to as SSH-1 and SSH-2.</p>
<p>The best-known application of the protocol is for access to shell accounts on Unix-like operating systems, but it can also be used in a similar fashion for accounts on Windows. It was designed as a replacement for Telnet and other insecure remote shell protocols such as the Berkeley rsh and rexec protocols, which send information, notably passwords, in plaintext, rendering them susceptible to interception and disclosure using packet analysis. The encryption used by SSH is intended to provide confidentiality and integrity of data over an unsecured network, such as the Internet.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<h2 id="key-types">Key Types</h2>
<p><a href="http://stackoverflow.com/questions/2841094/what-is-the-difference-between-dsa-and-rsa">Source</a></p>
<p>DSA is faster in signing, but slower in verifying. A DSA key of the same strength as RSA (1024 bits) generates a smaller signature. An RSA 512 bit key has been cracked, but only a 280 DSA key.</p>
<p>Also note that DSA can only be used for <strong>signing/verification</strong>, whereas RSA can be used for <strong>encryption/decrypt</strong> as well.</p>
<h2 id="summary-of-useful-commands">Summary of Useful Commands</h2>
<table>
<thead>
<tr class="header">
<th>Command</th>
<th>Example</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ssh</td>
<td>ssh <a href="mailto:kevin@thor.local">kevin@thor.local</a></td>
<td>login to a computer</td>
</tr>
<tr class="even">
<td>ssh-keygen</td>
<td>ssh-keygen</td>
<td>generate an ssh key</td>
</tr>
<tr class="odd">
<td>ssh-keygen</td>
<td>ssh-keygen -lvf</td>
<td>view the key finger print</td>
</tr>
<tr class="even">
<td>ssh-copy-id</td>
<td>ssh-copy-id <a href="mailto:kevin@loki.local">kevin@loki.local</a></td>
<td>copy key to remote server</td>
</tr>
</tbody>
</table>
<h2 id="key-generation">Key Generation</h2>
<p>To increase security, you can disable password logins and rely on ssh public keys. To do this, take a look <a href="https://wiki.archlinux.org/index.php/SSH_Keys">here</a> for details. Basic steps are:</p>
<ol type="1">
<li><p>Generate an ssh key pair using either RSA (2048-4096 bit) or DSA (1024 bit) both public and private keys. They will be stored in <code>~/.ssh</code> with the public key having .pub appended to the end. Two ways to generate keys are shown below (pick one).</p>
<pre><code>ssh-keygen -t dsa -b 1024 -C &quot;$(whoami)@$(hostname)-$(date)&quot;
ssh-keygen -t rsa -b 4096 -C &quot;$(whoami)@$(hostname)-$(date)&quot;</code></pre>
<p>Note you can create a key for a different username if you change $(whoami) to the user name you want. If no type is specified, the default is RSA 2048 bits.</p>
<pre><code>[kevin@Tardis ~]$ ssh-keygen -C &quot;test@$(hostname)-$(date)&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/kevin/.ssh/id_rsa): test
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in test.
Your public key has been saved in test.pub.
The key fingerprint is:
00:04:27:9d:7e:33:6f:65:1c:a5:e0:c3:82:5d:7b:92 test@Tardis.local-Tue Apr 21 22:29:40 MDT 2015
The key&#39;s randomart image is:
+--[ RSA 2048]----+
|  o++.  o  ..    |
|   oo+ + +..     |
|   .. + E.o.     |
|    . +o ++      |
|     . +So       |
|        o        |
|       .         |
|                 |
|                 |
+-----------------+</code></pre>
<p>Also note, it is advisable you create a strong pass phrase that you won't forget. However, I typically do not create one. But it does add an added level of protection.</p></li>
<li><p>Copy the public key (.pub) to the server you will connect to:</p>
<pre><code>ssh-copy-id username@remote-server.org</code></pre>
<p>This will update ~/.ssh/authorized_keys in the process. <strong>Note:</strong> <code>ssh-copy-id</code> may need to be installed. Most Linux/Unix systems should have this, but for OSX do <code>brew install ssh-copy-id</code>. Also ensure the correct protections are on the file by:</p>
<pre><code>chmod 600 ~/.ssh/authorized_keys</code></pre></li>
<li><p>Edit /etc/ssh/sshd_config to disable password logins.</p>
<pre><code>PasswordAuthentication no
ChallengeResponseAuthentication no</code></pre></li>
</ol>
<h2 id="ssh-key-finger-prints">SSH Key Finger Prints</h2>
<p>To view the finger print of a key:</p>
<pre><code>[kevin@Tardis ~]$ ssh-keygen -lvf ~/.ssh/id_rsa.pub
2048 b1:58:41:c5:93:b3:bc:c7:34:5b:e8:be:bc:15:ff:55  kevin@tardis.local (RSA)
+--[ RSA 2048]----+
|       .oo..     |
|         .=      |
|        o. + .   |
|       o oo + .  |
|      . S  = +. E|
|          . =  o.|
|           o  . o|
|           ...  o|
|            +o  .|
+-----------------+</code></pre>
<p>This tells you the type of key (e.g., RSA or DSA), the bit size, what email/account it is tied to, and a graphical representation of the key. In this case, the 2048 bits of my public RSA key.</p>
<h2 id="config">Config</h2>
<p>By default, ssh uses id_rsa.pub. If you want to match a specific key to a specific host, you need a <code>~/.ssh/config</code> file. Example:</p>
<pre><code>Host bitbucket.org
 IdentityFile ~/.ssh/bitbucket_rsa
Host github.com
 IdentityFile ~/.ssh/github_rsa</code></pre>
<h2 id="ssh-hacks">16 SSH Hacks</h2>
<p>The original source for this work is <a href="http://www.itworld.com/it-managementstrategy/261500/16-ultimate-openssh-hacks">here</a></p>
<p>So you think you know OpenSSH inside and out? Test your chops against this hit parade of 16 expert tips and tricks, from identifying monkey-in-the-middle attacks to road warrior security to attaching remote screen sessions. Follow the countdown to the all-time best OpenSSH command!</p>
<p><a href="xhttp://www.itworld.com/nls_unixssh0500506">Running SSH on a non-standard port</a></p>
<h3 id="ssh-tips-16-14detecting-mitm-attacks">SSH tips #16-14:Detecting MITM attacks</h3>
<p>When you log into a remote computer for the first time, you are asked if you want to accept the remote host's public key. Well how in the heck do you know if you should or not? If someone perpetrated a successful monkey-in-the-middle attack, and is presenting you with a fake key so they can hijack your session and steal all your secrets, how are you supposed to know? You can know, because when new key pairs are created they also create a unique fingerprint and randomart image:</p>
<pre><code>$ ssh-keygen -t rsa -C newserver -f .ssh/newkey

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in .ssh/newkey.
Your public key has been saved in .ssh/newkey.pub.
The key fingerprint is:
44:90:8c:62:6e:53:3b:d8:1a:67:34:2f:94:02:e4:87 newserver
The key&#39;s randomart image is:
+--[ RSA 2048]----+
|oo   +.o.        |
|. = B o.         |
| E X +  .        |
|  B B ..         |
| . * o  S        |
|  .              |
|                 |
|                 |
|                 |
+-----------------+</code></pre>
<h3 id="ssh-tip-16-retrieve-the-fingerprint-and-randomart-image-of-an-ssh-key">SSH tip #16: Retrieve the fingerprint and randomart image of an SSH key</h3>
<p>If you make a copy of this when you create new encryption keys, then you can fetch a key's fingerprint and randomart image anytime to compare and make sure they have not changed:</p>
<pre><code>$ ssh-keygen -lvf  keyname</code></pre>
<h3 id="ssh-tip-15-view-all-fingerprints-and-randomart-images-in-known_hosts">SSH tip #15: View all fingerprints and randomart images in known_hosts</h3>
<p>And you can see all of them in your ~/.ssh/known_hosts file:</p>
<pre><code>$ ssh-keygen -lvf ~/.ssh/known_hosts</code></pre>
<h3 id="ssh-tip-14-verify-server-keys">SSH tip #14: Verify server keys</h3>
<p>You can see the fingerprint and randomart for any computer you're logging into by configuring/etc/ssh/ssh_config on your client computer. Simply uncomment the VisualHostKey option and set it to yes:</p>
<pre><code>VisualHostKey yes</code></pre>
<p>Then login to any remote computer to test it:</p>
<pre><code>$ ssh user@host2
Host key fingerprint is 66:a1:2a:23:4d:5c:8b:58:e7:ef:2f:e5:49:3b:3d:32
+--[ECDSA  256]---+
|                 |
|                 |
|  . o   .        |
| + = . . .       |
|. + o . S        |
| o   o oo        |
|. + . .+ +       |
| . o .. E o      |
|      .o.+ .     |
+-----------------+

user@host2&#39;s password:</code></pre>
<p>Obviously you need a secure method of getting verified copies of the fingerprint and randomart images for the computers you want to log into. Like a hand-delivered printed copy, encrypted email, the scp command, secure ftp, read over the telephone...The risk of a successful MITM attack is small, but if you can figure out a relatively painless verification method it's cheap insurance.</p>
<h3 id="ssh-tip-13-attach-to-a-remote-gnu-screen-session">SSH tip #13: Attach to a remote GNU screen session</h3>
<p>You can attach a GNU screen session remotely over SSH; in this example we'll open a GNU screen session on host1, and connect to it from host2. First open and then detach a screen session on host1, named testscreen:</p>
<pre><code>host1 ~ $ screen -S testscreen</code></pre>
<p>Then detach from your screen session with the keyboard combination Ctrl+a+d:</p>
<pre><code>[detached from 3829.testscreen]</code></pre>
<p>You can verify that it's still there with this command:</p>
<pre><code>host1 ~ $ screen -ls</code></pre>
<p>There is a screen on:</p>
<pre><code>3941.testscreen (03/18/2012 12:43:42 PM) (Detached)
1 Socket in /var/run/screen/S-host1.</code></pre>
<p>Then re-attach to your screen session from host2:</p>
<pre><code>host1 ~ $ ssh -t terry@uberpc screen -r testscreen</code></pre>
<p>You don't have to name the screen session if there is only one.</p>
<h3 id="vssh-tip-12-launch-a-remote-screen-session">vSSH tip #12: Launch a remote screen session</h3>
<p>What if you don't have a running screen session? No worries, because you can launch one remotely:</p>
<pre><code>host1 ~ $ ssh -t user@host2 /usr/bin/screen -xRR</code></pre>
<h3 id="ssh-tip-11-sshfs-is-better-than-nfs">SSH tip #11: SSHFS is better than NFS</h3>
<p>sshfs is better than NFS for a single user with multiple machines. I keep a herd of computers running because it's part of my job to always be testing stuff. I like having nice friendly herds of computers. Some people collect Elvis plates, I gather computers. At any rate opening files one at a time over an SSH session for editing is slow; with sshfs you can mount entire directories from remote computers. First create a directory to mount your sshfs share in:</p>
<pre><code>$ mkdir remote2</code></pre>
<p>Then mount whatever remote directory you want like this:</p>
<pre><code>$ sshfs user@remote2:/home/user/documents remote2/</code></pre>
<p>Now you can browse the remote directory just as though it were local, and read, copy, move, and edit files all you want. The neat thing about sshfs is all you need is sshd running on your remote machines, and thesshfs command installed on your client PCs.</p>
<h3 id="ssh-tip-10-log-in-and-run-a-command-in-one-step">SSH tip #10: Log in and run a command in one step</h3>
<p>You can log in and establish your SSH session and then run commands, but when you have a single command to run why not eliminate a step and do it with a single command? Suppose you want to power off a remote computer; you can log in and run the command in one step:</p>
<pre><code>carla@local:~$ ssh user@remotehost sudo poweroff</code></pre>
<p>This works for any command or script. (The example assumes you have a sudo user set up with appropriate restrictions, because allowing a root login over SSH is considered an unsafe practice.) What if you want to run a long complex command, and don't want to type it out every time? One way is to put it in a Bash alias and use that. Another way is to put your long complex command in a text file and run it according to tip #9.</p>
<h3 id="ssh-tip-9-putting-long-commands-in-text-files">SSH tip #9: Putting long commands in text files</h3>
<p>Put your long command in a plain text file on your local PC, and then use it this way to log in and run it on the remote PC:</p>
<pre><code>carla@local:~$ ssh user@remotehost &quot;`cat filename.txt`&quot;</code></pre>
<p>Mind that you use straight quotations marks and not fancy ones copied from a Web page, and back-ticks, not single apostrophes.</p>
<h3 id="vssh-tip-8-copy-public-keys-the-easy-way">vSSH tip #8: Copy public keys the easy way</h3>
<p>The ssh-copy-id command is not as well-known as it should be, which is a shame because it is a great time-saver. This nifty command copies your public key to a remote host in the correct format, and to the correct directory. It even has a safety check that won't let you copy a private key by mistake. Specify which key you want to copy, like this:</p>
<pre><code>$ ssh-copy-id -i .ssh/id_rsa.pub user@remote</code></pre>
<h3 id="ssh-tip-7-give-ssh-keys-unique-names">SSH tip #7: Give SSH keys unique names</h3>
<p>Speaking of key names, did you know you can name them anything you want? This helps when you're administering a number of remote computers, like this example which creates then private key web-admin and public key web-admin.pub:</p>
<pre><code>$ ssh-keygen -t rsa -f .ssh/web-admin</code></pre>
<h3 id="ssh-tip-6-give-ssh-keys-informative-comments">SSH tip #6: Give SSH keys informative comments</h3>
<p>Another useful way to label keys is with a comment:</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;downtown lan webserver&quot; -f .ssh/web-admin</code></pre>
<p>Then you can read your comment which is appended to the end of the public key.</p>
<h3 id="ssh-tip-5-read-public-key-comments">SSH tip #5: Read public key comments</h3>
<pre><code>$ less .ssh/web-admin.pub

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC1

[snip] KCLAqwTv8rhp downtown lan webserver</code></pre>
<h3 id="ssh-tip-4-logging-in-with-server-specific-keys">SSH tip #4: Logging in with server-specific keys</h3>
<p>Then when you log in, specify which key to use with the -i switch:</p>
<pre><code>$ ssh -i .ssh/web-admin.pub user@webserver</code></pre>
<h3 id="ssh-tip-3-fast-easy-known_hosts-key-management">SSH tip #3: Fast easy known_hosts key management</h3>
<p>I love this one because it's a nice time-saver, and it keeps my ~/.ssh/known_hosts files tidy: using ssh-keygen to remove host keys from the ~/.ssh/known_hosts file. When the remote machine gets new SSH keys you'll get a warning, when you try to log in, that the key has changed. Using this is much faster than manually editing the file and counting down to the correct line to delete:</p>
<pre><code>$ ssh-keygen -R remote-hostname</code></pre>
<p>Computers are supposed to make our lives easier, and it's ever so lovely when they do.</p>
<h3 id="ssh-tip-2-ssh-tunnel-for-road-warriors">SSH tip #2: SSH tunnel for road warriors</h3>
<p>When you're at the mercy of hotel and coffee shop Internet, a nice secure SSH tunnel makes your online adventures safer. To make this work you need a server that you control to act as a central node for escaping from hotspot follies. I have a server set up at home to accept remote SSH logins, and then use an SSH tunnel to route traffic through it. This is useful for a lot of different tasks. For example I can use my normal email client to send email, instead of hassling with Web mail or changing SMTP server configuration, and all traffic between my laptop and home server is encrypted. First create the tunnel to your personal server:</p>
<pre><code>carla@hotel:~$ ssh -f carla@homeserver.com -L 9999:homeserver.com:25 -N</code></pre>
<p>This binds port 9999 on your mobile machine to port 25 on your remote server. The remote port must be whatever you've configured your server to listen on. Then configure your mail client to use localhost:9999 as the SMTP server and you're in business. I use Kmail, which lets me configure multiple SMTP server accounts and then choose which one I want to use when I send messages, or simply change the default with a mouse click. You can adapt this for any kind of service that you normally use from your home base, and need access to when you're on the road.</p>
<h3 id="favorite-ssh-tip-evading-silly-web-restrictions">1 Favorite SSH tip: Evading silly web restrictions</h3>
<p>The wise assumption is that any public Internet is untrustworthy, so you can tunnel your Web surfing too. My #1 SSH tip gets you past untrustworthy networks that might have snoopers, and past any barriers to unfettered Web-surfing. Just like in tip #2 you need a server that you control to act as a secure relay; first setup an SSH tunnel to this server:</p>
<pre><code>carla@hotel:~$ ssh -D 9999 -C carla@homeserver.com</code></pre>
<p>Then configure your Web browser to use port 9999 as a SOCKS 5 proxy. Figure 1 shows how this looks in Firefox.</p>
<p>Figure 1: Configuring Firefox to use your SSH tunnel as a SOCKS proxy. An easy way to test this is on your home or business network. Set up the tunnel to a neighboring PC and surf some external Web sites. When this works go back and change the SOCKS port number to the wrong number. This should prevent your Web browser from connecting to any sites, and you'll know you set up your tunnel correctly. How do you know which port numbers to use? Port numbers above 1024 do not require root privileges, so use these on your laptop or whatever you're using in your travels. Always check /etc/services first to find unassigned ports. The remote port you're binding to must be a port a server is listening on, and there has to be a path through your firewall to get to it.</p>
<p>To learn more try the excellent [Pro OpenSSH by Michael Stahnke] (<a href="http://www.apress.com/networking/openssh/9781590594766" class="uri">http://www.apress.com/networking/openssh/9781590594766</a>), and my own <a href="http://www.amazon.com/Linux-Networking-Cookbook-Carla-Schroder/dp/0596102488">Linux Networking Cookbook</a> has more on secure remote administration including SSH, OpenVPN, and remote graphical sessions, and configuring firewalls.</p>
<h2 id="crypto-keys">Crypto Keys</h2>
<p><a href="http://crypto.stackexchange.com/questions/6585/gpg-vs-pgp-vs-openssh-and-management-of-them">Source</a></p>
<pre><code>What is the main difference of the three? Can I use only one of them for everything
(e.g. GPG for SSH authentication)</code></pre>
<ul>
<li>GnuPG is an free and open-source implementation of the OpenPGP standard.</li>
<li>Symantec PGP is a proprietary implementation of the OpenPGP standard.</li>
<li>The OpenPGP standard defines ways to sign and encrypt information (like mail, other documents and code/software).</li>
<li>OpenSSH is about connection securely to remote computers. For authenticating you need some secret, usually this is a passphrase or SSH key.</li>
</ul>
<p>With OpenPGP, you hold a secret (private key) which also can be used for authenticating yourself. It needs software support for that, and I haven't heard of some code doing this for (Symantec) PGP, <a href="http://budts.be/weblog/2012/08/ssh-authentication-with-your-pgp-key">but there is a way doing this with GnuPG</a>.</p>
<pre><code>If I encrypt my private key with a pass-phrase, is it strong enough so that if someone
steals my laptop or private key, I&#39;m safe?</code></pre>
<p>Your password encrypts your private key. The key is safe as long as your password is safe. If your password is too weak (dictionary-attacks, not long enough, easy to brute-force for other reasons), your key is vulnerable, too.</p>
<p>Think about how valuable your key is for an attacker and choose fitting security measures like storing your key offline (<a href="http://security.stackexchange.com/a/31598/19837">in the and of this answer</a>).</p>
<pre><code>If not, what about encrypting my private key with the scrypt algorithm?</code></pre>
<p>If doing so, security depends on the password you're using for scrypt and scrypt's algorithm. You can achieve the same amount of security with a good OpenPGP password, so there is no need for additionally encrypting your key.</p>
<h2 id="fingerprints">Fingerprints</h2>
<p>Generate an easier to understand fingerprint (or thumbprint) from a long public key:</p>
<pre><code>[kevin@Tardis ~]$ ssh-keygen -lf .ssh/test_rsa_key.pub
2048 d0:4a:98:88:95:65:6e:3c:59:7d:10:db:1d:00:10:40  kevin@tardis.local (RSA)</code></pre>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://en.wikipedia.org/wiki/Secure_Shell">Wikipedia entry source</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

            
          </div>

        </div>
    </body>

    <div id="footer-wrapper">

  <div class="logo"></div>

  <div class="logo">
    <a class="logo" href="http://github.com/walchko"><i class="fl-github fl-36"></i></a>
    <a class="logo" href="http://stackoverflow.com/users/5374768/kevin"><i class="fl-stackoverflow fl-36"></i></a>
    <a class="logo" href="http://raspberrypi.stackexchange.com/users/1677/kevin"><i class="fl-stackexchange fl-36"></i></a>
    <a class="logo" href="https://www.npmjs.com/~kevin.walchko"><i class="fl-npm fl-36"></i></a>
    <a class="logo" href="https://pypi.python.org/pypi"><i class="fl-python fl-36"></i></a>
    <a class="logo" href="https://bitbucket.org/walchko/"><i class="fl-bitbucket fl-36"></i></a>
  </div>

  <div class="logo">
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
      <i class="cc cc-by-sa cc-lg"></i>
    </a>
  </div>

  <div class="pure-u-1">
    <a class="logo" href="https://github.com/walchko/pelican">&copy;&nbsp;2016&nbsp;Kevin J. Walchko</a>
  </div>

</div>


</html>
