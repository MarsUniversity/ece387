<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <!-- <link rel='stylesheet' type='text/css' href='https://cdn.rawgit.com/MarsUniversity/ece387/master/website/pandoc.css'> -->
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
    	<link href="https://cdnjs.cloudflare.com/ajax/libs/cc-icons/1.2.1/css/cc-icons.min.css" rel="stylesheet">
    	<link href="https://cdn.rawgit.com/walchko/font-linux/v0.7.2/assets/font-linux.css" rel="stylesheet">
      <!-- <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"> -->
      <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro" rel="stylesheet">
      <link href="https://walchko.github.io/site.css" rel="stylesheet" type="text/css" />
      <!-- <link href="../../site.css" rel="stylesheet" type="text/css" /> -->
    	<!-- <link href="https://walchko.github.io/pygments.css" rel="stylesheet" type="text/css" /> -->
      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [["$","$"],["\\(","\\)"]]
          }
        });
      </script>

	  <!-- code pulled from jupyter nbconvert for syntax coloring -->
	  <style type="text/css">
    .highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>

    </head>
    <body>
      <div id="outer-wrapper">
        <div id="header-wrapper">
  <div class="title xtralarge bold"><a href="https://walchko.github.io/index.html">Planet Express</a></div>
  <div class="normal small"> Our crew is replaceable. Your package isn't. </div>

  <div class="nav normal">
    <a class="logo" href="https://walchko.github.io/index.html">Home</a>
    <a class="logo" href="https://walchko.github.io/colophon.html">Colophon</a>
    <a class="logo" href="https://walchko.github.io/about.html">About</a>
    <a class="logo" href="https://walchko.github.io/topics.html">Topics</a>
  </div>
</div>


          <div id="main">
            
            
              <h1 id="localization">Localization</h1>
<dl>
<dt>date</dt>
<dd><p>2016-04-05</p>
</dd>
<dt>summary</dt>
<dd><p>Review of robot localization - still a work in progress</p>
</dd>
</dl>
<p>These notes were taken from the <a href="http://www.udacity.com">Udacities</a> course I took on robotics and also follows Dr. Thrun's book <em>Probabilistic Robotics</em></p>
<dl>
<dt>Localization</dt>
<dd><p>Estimating a robot's coordinates in an external (e.g., world) reference frame. Typically this is the transformation between a robot's local frame and a global (world) reference frame. This allows a robot to determine its pose (x,y,<span class="math inline"><em>θ</em></span>) by fusing multiple noisy sensor readings in its local frame and either manipulating objects in the global map or navigating through free space in the global map.</p>
</dd>
<dt>Belief</dt>
<dd><p>A robot's momentary estimate of its location, represented as a probability density function, over the entire space of all locations</p>
</dd>
<dt>Location</dt>
<dd><p>A robots position in an external reference frame (e.g., <span class="math inline">(<em>x</em>, <em>y</em>)</span>)</p>
</dd>
<dt>Pose</dt>
<dd><p>A robot's location with its orientation (e.g., <span class="math inline">(<em>x</em>, <em>y</em>, <em>θ</em>)</span>)</p>
</dd>
<dt>Prior Belief</dt>
<dd><p>Start/initialize the belief to a uniform max confusion</p>
</dd>
<dt>Posterior Belief</dt>
<dd><p>After measurements are taken</p>
</dd>
<dt>Position Tracking</dt>
<dd><p>When a robot estimate's its pose over time given an initial pose.</p>
</dd>
<dt>Global Localization</dt>
<dd><p>When a robot must figure out where it is and it was not given an initial pose.</p>
</dd>
<dt>Kidnapped Robot</dt>
<dd><p>Although a robot will probably not be kidnapped, the realistic situation is a robot whose global localization has failed. Thus, the robot thinks it is somewhere it is not. Eventually, sensor readings will appear that will force the robot to realize it doesn't know where it is. Therefore, a robot must be able to recover from a failure of this type.</p>
</dd>
</dl>
<figure>
<img src="pics/monte-carlo.png" class="align-center" />
</figure>
<p><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>z</em>)</span> posterior distribution given measurement z</p>
<h2 id="inaccurate-robot-motion">Inaccurate Robot Motion</h2>
<figure>
<img src="pics/bad_robot_motion.png" class="align-center" width="500" />
</figure>
<p><br /><span class="math display"><em>p</em>(<em>x</em><sub><em>i</em> + 2</sub>|<em>x</em><sub><em>i</em></sub>) = 0.8<em>p</em>(<em>x</em><sub><em>i</em> + 1</sub>|<em>x</em><sub><em>i</em></sub>) = 0.1<em>p</em>(<em>x</em><sub><em>i</em> + 3</sub>|<em>x</em><sub><em>i</em></sub>) = 0.1</span><br /></p>
<figure>
<img src="pics/robot_state_transition.png" class="align-center" width="500" />
</figure>
<ul>
<li>loose info from movement</li>
<li>gains info from sensing</li>
</ul>
<p>entropy: <span class="math inline">∑<em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>l</em><em>o</em><em>g</em><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></p>
<h2 id="types-of-localization-filters">Types of Localization Filters</h2>
<table>
<thead>
<tr class="header">
<th>Filter</th>
<th>Type</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kalman Filter (KF)</td>
<td>Probabalistic</td>
<td>Linear</td>
</tr>
<tr class="even">
<td>Extended Kalman Filter (EKF)</td>
<td>Probabalistic</td>
<td>Non-linear equations linearized by taking 1st derivative (e.g., Jacobian)</td>
</tr>
<tr class="odd">
<td>Information Filter</td>
<td>Probabalistic</td>
<td>Linear</td>
</tr>
<tr class="even">
<td>Histogram Filter (HF)</td>
<td>Non-parametric</td>
<td>Decomposes state space into finite many convex regions and represents the cumulative posterior for each region by a single probability value</td>
</tr>
<tr class="odd">
<td>Partical Filter (PF)</td>
<td>Non-parametric</td>
<td>Like the HF, it approximates the posterior by a finite number of parameters. The samples of the posterior are called 'particals'</td>
</tr>
</tbody>
</table>
<h3 id="simple-example">Simple Example</h3>
<p>Taken from <strong>Probabilistic Robots</strong>, the figure below shows how a robot figures out globally where it is.</p>
<figure>
<img src="pics/markov_localization.jpg" class="align-center" />
</figure>
<ul>
<li>The first position, the robot doesn't know where it is, so the belief (<span class="math inline"><em>o</em><em>v</em><em>e</em><em>r</em><em>l</em><em>i</em><em>n</em><em>e</em><em>b</em><em>e</em><em>l</em><sub>0</sub>(<em>x</em>)</span> is set equally for all locations</li>
<li>Next, the robot detects a door, so the position, <span class="math inline"><em>p</em>(<em>z</em><sub>0</sub>|<em>x</em>)</span>, is set to likely infront of every door on the map.</li>
<li>The belief function is updated by multiplying the position esitmate with the previous belief. Now the robot thinks it is equally likely it is infront of a door, but low probability it is anywhere along the wall.</li>
<li>The robot move a distance and also moves the belief distrobution an equal amount ... note it is now infront of another door (different than the first)</li>
<li>Again, the position is updated such that the robot believes it is infront of a door, but it is unable to determine which door.</li>
<li>Updating the belief function with this new information (old belief multiplied with new position) results in the robot now believing strongly it is infront of the second door.</li>
<li>Moving the robot some more (and the belief distrobution), the robot knows it is not infront of a door, but somewhere along a wall. Updating the current belief function (position given it is not infront of door multiplied by the old belief function moved the distance the robot moved) results in the robot believing it is somewhere along the wall.</li>
</ul>
<p>Markov localization is independed of the underlying representation of the state space.</p>
<h2 id="references">References</h2>
<ul>
<li>Sebastian Thrun, Wolfram Burgard, and Dieter Fox. 2005. Probabilistic Robotics (Intelligent Robotics and Autonomous Agents). The MIT Press.</li>
<li><a href="https://en.wikipedia.org/wiki/Particle_filter">Partical filters on Wikipedia</a></li>
</ul>

            
          </div>

        </div>
    </body>

    <div id="footer-wrapper">

  <div class="logo"></div>

  <div class="logo">
    <a class="logo" href="http://github.com/walchko"><i class="fl-github fl-36"></i></a>
    <a class="logo" href="http://stackoverflow.com/users/5374768/kevin"><i class="fl-stackoverflow fl-36"></i></a>
    <a class="logo" href="http://raspberrypi.stackexchange.com/users/1677/kevin"><i class="fl-stackexchange fl-36"></i></a>
    <a class="logo" href="https://www.npmjs.com/~kevin.walchko"><i class="fl-npm fl-36"></i></a>
    <a class="logo" href="https://pypi.python.org/pypi"><i class="fl-python fl-36"></i></a>
    <a class="logo" href="https://bitbucket.org/walchko/"><i class="fl-bitbucket fl-36"></i></a>
  </div>

  <div class="logo">
    <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
      <i class="cc cc-by-sa cc-lg"></i>
    </a>
  </div>

  <div class="pure-u-1">
    <a class="logo" href="https://github.com/walchko/pelican">&copy;&nbsp;2016&nbsp;Kevin J. Walchko</a>
  </div>

</div>


</html>
